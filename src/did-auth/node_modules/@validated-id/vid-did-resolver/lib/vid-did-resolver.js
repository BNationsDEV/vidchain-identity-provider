"use strict";

var _ethjsProviderHttp = _interopRequireDefault(require("ethjs-provider-http"));

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _ethjsAbi = _interopRequireDefault(require("ethjs-abi"));

var _bn = _interopRequireDefault(require("bn.js"));

var _ethjsContract = _interopRequireDefault(require("ethjs-contract"));

var _ethrDidRegistry = _interopRequireDefault(require("../contracts/ethr-did-registry.json"));

var _networks = _interopRequireDefault(require("./networks.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var REGISTRY = "0xdca7ef03e98e0dc2b855be647c39abe984fcf21b";

function bytes32toString(bytes32) {
  return Buffer.from(bytes32.slice(2), "hex").toString("utf8").replace(/\0+$/, "");
}

function stringToBytes32(str) {
  var buffstr = "0x".concat(Buffer.from(str).slice(0, 32).toString("hex"));
  return buffstr + "0".repeat(66 - buffstr.length);
}

var delegateTypes = {
  Secp256k1SignatureAuthentication2018: stringToBytes32("sigAuth"),
  Secp256k1VerificationKey2018: stringToBytes32("veriKey")
};
var attrTypes = {
  sigAuth: "SignatureAuthentication2018",
  veriKey: "VerificationKey2018"
};

function wrapDidDocument(did, owner, history) {
  var now = new _bn["default"](Math.floor(new Date().getTime() / 1000)); // const expired = {}

  var publicKey = [{
    id: "".concat(did, "#owner"),
    type: "Secp256k1VerificationKey2018",
    owner: did,
    ethereumAddress: owner
  }];
  var authentication = [{
    type: "Secp256k1SignatureAuthentication2018",
    publicKey: "".concat(did, "#owner")
  }];
  var delegateCount = 0;
  var auth = {};
  var pks = {};
  var services = {}; // eslint-disable-next-line no-restricted-syntax

  var _iterator = _createForOfIteratorHelper(history),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var event = _step.value;
      var validTo = event.validTo;
      var key = "".concat(event._eventName, "-").concat(event.delegateType || event.name, "-").concat(event.delegate || event.value);

      if (validTo && validTo.gte(now)) {
        if (event._eventName === "DIDDelegateChanged") {
          delegateCount += 1;
          var delegateType = bytes32toString(event.delegateType);

          switch (delegateType) {
            case "sigAuth":
              auth[key] = {
                type: "Secp256k1SignatureAuthentication2018",
                publicKey: "".concat(did, "#delegate-").concat(delegateCount)
              };
            // eslint-disable-line no-fallthrough

            case "veriKey":
              pks[key] = {
                id: "".concat(did, "#delegate-").concat(delegateCount),
                type: "Secp256k1VerificationKey2018",
                owner: did,
                ethereumAddress: event.delegate
              };
              break;

            default:
              throw new Error("method ".concat(delegateType, " not supported"));
          }
        } else if (event._eventName === "DIDAttributeChanged") {
          var name = bytes32toString(event.name);
          var match = name.match(/^did\/(pub|auth|svc)\/(\w+)(\/(\w+))?(\/(\w+))?$/);

          if (match) {
            var section = match[1];
            var algo = match[2];
            var type = attrTypes[match[4]] || match[4];
            var encoding = match[6];
            var pk = {
              id: "".concat(did, "#delegate-").concat(delegateCount),
              type: "".concat(algo).concat(type),
              owner: did
            };

            switch (section) {
              case "pub":
                delegateCount += 1;

                switch (encoding) {
                  case null:
                  case undefined:
                  case "hex":
                    pk.publicKeyHex = event.value.slice(2);
                    break;

                  case "base64":
                    pk.publicKeyBase64 = Buffer.from(event.value.slice(2), "hex").toString("base64");
                    break;

                  case "base58":
                    pk.publicKeyBase58 = Buffer.from(event.value.slice(2), "hex").toString("base58");
                    break;

                  case "pem":
                    pk.publicKeyPem = Buffer.from(event.value.slice(2), "hex").toString();
                    break;

                  default:
                    pk.value = event.value;
                }

                pks[key] = pk;
                break;

              case "svc":
                services[key] = {
                  type: algo,
                  serviceEndpoint: Buffer.from(event.value.slice(2), "hex").toString()
                };
                break;

              default:
                throw new Error("method ".concat(encoding, " not supported"));
            }
          }
        }
      } else {
        if (delegateCount > 0 && (event._eventName === "DIDDelegateChanged" || event._eventName === "DIDAttributeChanged" && bytes32toString(event.name).match(/^did\/pub\//)) && validTo.lt(now)) {
          delegateCount -= 1;
        }

        delete auth[key];
        delete pks[key];
        delete services[key];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var doc = {
    "@context": "https://w3id.org/did/v1",
    id: did,
    publicKey: publicKey.concat(Object.values(pks)),
    authentication: authentication.concat(Object.values(auth))
  };

  if (Object.values(services).length > 0) {
    doc.service = Object.values(services);
  }

  return doc;
}

function configureProvider() {
  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (conf.provider) {
    return conf.provider;
  }

  if (conf.web3) {
    return conf.web3.currentProvider;
  }

  return new _ethjsProviderHttp["default"](conf.rpcUrl || "https://ropsten.infura.io/v3/");
}

function configureNetwork() {
  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provider = configureProvider(conf);
  var eth = new _ethjsQuery["default"](provider);
  var registryAddress = conf.registry || REGISTRY;
  var DidReg = new _ethjsContract["default"](eth)(_ethrDidRegistry["default"]);
  var didReg = DidReg.at(registryAddress);
  return {
    eth: eth,
    registryAddress: registryAddress,
    didReg: didReg
  };
}

function configureNetworks() {
  var networksConf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var networks = {}; // eslint-disable-next-line no-plusplus

  for (var i = 0; i < networksConf.length; i++) {
    var net = networksConf[i];
    networks[net.name] = configureNetwork(net);
  }

  return networks;
}

function getResolver() {
  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var logDecoder = _ethjsAbi["default"].logDecoder(_ethrDidRegistry["default"], false);

  var networks = _objectSpread(_objectSpread({
    mainnet: configureNetwork(conf)
  }, configureNetworks(_networks["default"])), configureNetworks(conf.networks)); // eslint-disable-next-line consistent-return


  var lastChanged = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(identity, networkId) {
      var result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return networks[networkId].didReg.changed(identity);

            case 2:
              result = _context.sent;

              if (!result) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return", result["0"]);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function lastChanged(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  function changeLog(_x3, _x4) {
    return _changeLog.apply(this, arguments);
  }

  function _changeLog() {
    _changeLog = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(identity, networkId) {
      var history, owner, previousChange, ownerRecord, blockNumber, logs, events, _iterator2, _step2, event;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              history = [];
              owner = identity;
              _context2.next = 4;
              return lastChanged(identity, networkId);

            case 4:
              previousChange = _context2.sent;

              if (!previousChange) {
                _context2.next = 10;
                break;
              }

              _context2.next = 8;
              return networks[networkId].didReg.identityOwner(identity);

            case 8:
              ownerRecord = _context2.sent;
              owner = ownerRecord["0"];

            case 10:
              if (!previousChange) {
                _context2.next = 21;
                break;
              }

              blockNumber = previousChange; // eslint-disable-next-line no-await-in-loop

              _context2.next = 14;
              return networks[networkId].eth.getLogs({
                address: networks[networkId].registryAddress,
                topics: [null, "0x000000000000000000000000".concat(identity.slice(2))],
                fromBlock: previousChange,
                toBlock: previousChange
              });

            case 14:
              logs = _context2.sent;
              events = logDecoder(logs);
              previousChange = undefined; // eslint-disable-next-line no-restricted-syntax

              _iterator2 = _createForOfIteratorHelper(events);

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  event = _step2.value;
                  history.unshift(event);

                  if (event.previousChange.lt(blockNumber)) {
                    previousChange = event.previousChange;
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              _context2.next = 10;
              break;

            case 21:
              return _context2.abrupt("return", {
                owner: owner,
                history: history
              });

            case 22:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _changeLog.apply(this, arguments);
  }

  function resolve(_x5, _x6) {
    return _resolve.apply(this, arguments);
  }

  function _resolve() {
    _resolve = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(did, parsed) {
      var fullId, id, networkId, _yield$changeLog, owner, history;

      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              fullId = parsed.id.match(/^(.*)?(0x[0-9a-fA-F]{40})$/);

              if (fullId) {
                _context3.next = 3;
                break;
              }

              throw new Error("Not a valid vid DID: ".concat(did));

            case 3:
              id = fullId[2];
              networkId = !fullId[1] ? "mainnet" : fullId[1].slice(0, -1);

              if (networks[networkId]) {
                _context3.next = 7;
                break;
              }

              throw new Error("No conf for networkId: ".concat(networkId));

            case 7:
              _context3.next = 9;
              return changeLog(id, networkId);

            case 9:
              _yield$changeLog = _context3.sent;
              owner = _yield$changeLog.owner;
              history = _yield$changeLog.history;
              return _context3.abrupt("return", wrapDidDocument(did, owner, history));

            case 13:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _resolve.apply(this, arguments);
  }

  return {
    ethr: resolve
  };
}

module.exports = {
  REGISTRY: REGISTRY,
  bytes32toString: bytes32toString,
  stringToBytes32: stringToBytes32,
  delegateTypes: delegateTypes,
  attrTypes: attrTypes,
  wrapDidDocument: wrapDidDocument,
  getResolver: getResolver
};