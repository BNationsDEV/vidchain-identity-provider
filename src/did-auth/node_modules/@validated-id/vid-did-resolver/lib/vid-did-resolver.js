"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.match");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.dom-collections.iterator");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/objectSpread2"));

var _at = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/at"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/values"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/concat"));

var _repeat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/repeat"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));

var _ethjsProviderHttp = _interopRequireDefault(require("ethjs-provider-http"));

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _ethjsAbi = _interopRequireDefault(require("ethjs-abi"));

var _bn = _interopRequireDefault(require("bn.js"));

var _ethjsContract = _interopRequireDefault(require("ethjs-contract"));

var _ethrDidRegistry = _interopRequireDefault(require("../contracts/ethr-did-registry.json"));

var _networks = _interopRequireDefault(require("./networks.json"));

/* eslint-disable no-underscore-dangle */
var REGISTRY = "0xdca7ef03e98e0dc2b855be647c39abe984fcf21b";

function bytes32toString(bytes32) {
  return Buffer.from((0, _slice.default)(bytes32).call(bytes32, 2), "hex").toString("utf8").replace(/\0+$/, "");
}

function stringToBytes32(str) {
  var _context, _context2;

  var buffstr = "0x".concat((0, _slice.default)(_context = Buffer.from(str)).call(_context, 0, 32).toString("hex"));
  return buffstr + (0, _repeat.default)(_context2 = "0").call(_context2, 66 - buffstr.length);
}

var delegateTypes = {
  Secp256k1SignatureAuthentication2018: stringToBytes32("sigAuth"),
  Secp256k1VerificationKey2018: stringToBytes32("veriKey")
};
var attrTypes = {
  sigAuth: "SignatureAuthentication2018",
  veriKey: "VerificationKey2018"
};

function wrapDidDocument(did, owner, history) {
  var _context5, _context6, _context9, _context10, _context11, _context12, _context13;

  var now = new _bn.default(Math.floor(new Date().getTime() / 1000)); // const expired = {}

  var publicKey = [{
    id: "".concat(did, "#owner"),
    type: "Secp256k1VerificationKey2018",
    owner: did,
    ethereumAddress: owner
  }];
  var authentication = [{
    type: "Secp256k1SignatureAuthentication2018",
    publicKey: "".concat(did, "#owner")
  }];
  var delegateCount = 0;
  var auth = {};
  var pks = {};
  var services = {}; // eslint-disable-next-line no-restricted-syntax

  for (var event of history) {
    var _context3, _context4;

    var {
      validTo
    } = event;
    var key = (0, _concat.default)(_context3 = (0, _concat.default)(_context4 = "".concat(event._eventName, "-")).call(_context4, event.delegateType || event.name, "-")).call(_context3, event.delegate || event.value);

    if (validTo && validTo.gte(now)) {
      if (event._eventName === "DIDDelegateChanged") {
        delegateCount += 1;
        var delegateType = bytes32toString(event.delegateType);

        switch (delegateType) {
          case "sigAuth":
            auth[key] = {
              type: "Secp256k1SignatureAuthentication2018",
              publicKey: (0, _concat.default)(_context5 = "".concat(did, "#delegate-")).call(_context5, delegateCount)
            };
          // eslint-disable-line no-fallthrough

          case "veriKey":
            pks[key] = {
              id: (0, _concat.default)(_context6 = "".concat(did, "#delegate-")).call(_context6, delegateCount),
              type: "Secp256k1VerificationKey2018",
              owner: did,
              ethereumAddress: event.delegate
            };
            break;

          default:
            throw new Error("method ".concat(delegateType, " not supported"));
        }
      } else if (event._eventName === "DIDAttributeChanged") {
        var name = bytes32toString(event.name);
        var match = name.match(/^did\/(pub|auth|svc)\/(\w+)(\/(\w+))?(\/(\w+))?$/);

        if (match) {
          var _context7, _context8;

          var section = match[1];
          var algo = match[2];
          var type = attrTypes[match[4]] || match[4];
          var encoding = match[6];
          var pk = {
            id: (0, _concat.default)(_context7 = "".concat(did, "#delegate-")).call(_context7, delegateCount),
            type: (0, _concat.default)(_context8 = "".concat(algo)).call(_context8, type),
            owner: did
          };

          switch (section) {
            case "pub":
              delegateCount += 1;

              switch (encoding) {
                case null:
                case undefined:
                case "hex":
                  pk.publicKeyHex = (0, _slice.default)(_context9 = event.value).call(_context9, 2);
                  break;

                case "base64":
                  pk.publicKeyBase64 = Buffer.from((0, _slice.default)(_context10 = event.value).call(_context10, 2), "hex").toString("base64");
                  break;

                case "base58":
                  pk.publicKeyBase58 = Buffer.from((0, _slice.default)(_context11 = event.value).call(_context11, 2), "hex").toString("base58");
                  break;

                case "pem":
                  pk.publicKeyPem = Buffer.from((0, _slice.default)(_context12 = event.value).call(_context12, 2), "hex").toString();
                  break;

                default:
                  pk.value = event.value;
              }

              pks[key] = pk;
              break;

            case "svc":
              services[key] = {
                type: algo,
                serviceEndpoint: Buffer.from((0, _slice.default)(_context13 = event.value).call(_context13, 2), "hex").toString()
              };
              break;

            default:
              throw new Error("method ".concat(encoding, " not supported"));
          }
        }
      }
    } else {
      if (delegateCount > 0 && (event._eventName === "DIDDelegateChanged" || event._eventName === "DIDAttributeChanged" && bytes32toString(event.name).match(/^did\/pub\//)) && validTo.lt(now)) {
        delegateCount -= 1;
      }

      delete auth[key];
      delete pks[key];
      delete services[key];
    }
  }

  var doc = {
    "@context": "https://w3id.org/did/v1",
    id: did,
    publicKey: (0, _concat.default)(publicKey).call(publicKey, (0, _values.default)(pks)),
    authentication: (0, _concat.default)(authentication).call(authentication, (0, _values.default)(auth))
  };

  if ((0, _values.default)(services).length > 0) {
    doc.service = (0, _values.default)(services);
  }

  return doc;
}

function configureProvider() {
  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (conf.provider) {
    return conf.provider;
  }

  if (conf.web3) {
    return conf.web3.currentProvider;
  }

  return new _ethjsProviderHttp.default(conf.rpcUrl || "https://ropsten.infura.io/v3/");
}

function configureNetwork() {
  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provider = configureProvider(conf);
  var eth = new _ethjsQuery.default(provider);
  var registryAddress = conf.registry || REGISTRY;
  var DidReg = new _ethjsContract.default(eth)(_ethrDidRegistry.default);
  var didReg = (0, _at.default)(DidReg).call(DidReg, registryAddress);
  return {
    eth,
    registryAddress,
    didReg
  };
}

function configureNetworks() {
  var networksConf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var networks = {}; // eslint-disable-next-line no-plusplus

  for (var i = 0; i < networksConf.length; i++) {
    var net = networksConf[i];
    networks[net.name] = configureNetwork(net);
  }

  return networks;
}

function getResolver() {
  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var logDecoder = _ethjsAbi.default.logDecoder(_ethrDidRegistry.default, false);

  var networks = (0, _objectSpread2.default)((0, _objectSpread2.default)({
    mainnet: configureNetwork(conf)
  }, configureNetworks(_networks.default)), configureNetworks(conf.networks)); // eslint-disable-next-line consistent-return

  var lastChanged = /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2.default)(function* (identity, networkId) {
      var result = yield networks[networkId].didReg.changed(identity);

      if (result) {
        return result["0"];
      }
    });

    return function lastChanged(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  function changeLog(_x3, _x4) {
    return _changeLog.apply(this, arguments);
  }

  function _changeLog() {
    _changeLog = (0, _asyncToGenerator2.default)(function* (identity, networkId) {
      var history = [];
      var owner = identity;
      var previousChange = yield lastChanged(identity, networkId);

      if (previousChange) {
        var ownerRecord = yield networks[networkId].didReg.identityOwner(identity);
        owner = ownerRecord["0"];
      }

      while (previousChange) {
        var blockNumber = previousChange; // eslint-disable-next-line no-await-in-loop

        var logs = yield networks[networkId].eth.getLogs({
          address: networks[networkId].registryAddress,
          topics: [null, "0x000000000000000000000000".concat((0, _slice.default)(identity).call(identity, 2))],
          fromBlock: previousChange,
          toBlock: previousChange
        });
        var events = logDecoder(logs);
        previousChange = undefined; // eslint-disable-next-line no-restricted-syntax

        for (var event of events) {
          history.unshift(event);

          if (event.previousChange.lt(blockNumber)) {
            previousChange = event.previousChange;
          }
        }
      }

      return {
        owner,
        history
      };
    });
    return _changeLog.apply(this, arguments);
  }

  function resolve(_x5, _x6) {
    return _resolve.apply(this, arguments);
  }

  function _resolve() {
    _resolve = (0, _asyncToGenerator2.default)(function* (did, parsed) {
      var _context14;

      var fullId = parsed.id.match(/^(.*)?(0x[0-9a-fA-F]{40})$/);
      if (!fullId) throw new Error("Not a valid vid DID: ".concat(did));
      var id = fullId[2];
      var networkId = !fullId[1] ? "mainnet" : (0, _slice.default)(_context14 = fullId[1]).call(_context14, 0, -1);
      if (!networks[networkId]) throw new Error("No conf for networkId: ".concat(networkId));
      var {
        owner,
        history
      } = yield changeLog(id, networkId);
      return wrapDidDocument(did, owner, history);
    });
    return _resolve.apply(this, arguments);
  }

  return {
    vid: resolve
  };
}

module.exports = {
  REGISTRY,
  bytes32toString,
  stringToBytes32,
  delegateTypes,
  attrTypes,
  wrapDidDocument,
  getResolver
};