{"version":3,"file":"index.js","sources":["../src/Digest.ts","../src/SimpleSigner.ts","../src/util.ts","../src/VerifierAlgorithm.ts","../src/SignerAlgorithm.ts","../src/JWT.ts","../src/NaclSigner.ts"],"sourcesContent":["import { sha256 as sha256js, Message } from 'js-sha256'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\nimport { Buffer } from 'buffer'\n\nexport function sha256(payload: Message): Buffer {\n  return Buffer.from(sha256js.arrayBuffer(payload))\n}\n\nexport function keccak(data: Message): Buffer {\n  return Buffer.from(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress(hexPublicKey: string): string {\n  return `0x${keccak(Buffer.from(hexPublicKey.slice(2), 'hex'))\n    .slice(-20)\n    .toString('hex')}`\n}\n","import { ec as EC, ec } from 'elliptic'\nimport { sha256 } from './Digest'\nimport { Signer } from './JWT'\n\nconst secp256k1: EC = new EC('secp256k1')\n\nfunction leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n/**\n *  The SimpleSigner returns a configured function for signing data. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  if (hexPrivateKey.startsWith('0x')) {\n    hexPrivateKey = hexPrivateKey.substring(2)\n  }\n  const privateKey: ec.KeyPair = secp256k1.keyFromPrivate(hexPrivateKey)\n  return async data => {\n    const { r, s, recoveryParam }: EC.Signature = privateKey.sign(sha256(data))\n    return {\n      r: leftpad(r.toString('hex')),\n      s: leftpad(s.toString('hex')),\n      recoveryParam\n    }\n  }\n}\n\nexport default SimpleSigner\n","export function base64ToBytes(s: string): Uint8Array {\n  return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0))\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return Buffer.from(b).toString('base64')\n}\n","import { ec as EC } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport base64url from 'uport-base64url'\nimport nacl from 'tweetnacl'\nimport { EcdsaSignature } from './JWT'\nimport { PublicKey } from 'did-resolver'\nimport { encode } from '@stablelib/utf8'\nimport { base64ToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(signature: string, recoverable = false): EcdsaSignature {\n  const rawsig: Buffer = base64url.toBuffer(signature)\n  if (rawsig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = rawsig.slice(0, 32).toString('hex')\n  const s: string = rawsig.slice(32, 64).toString('hex')\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64]\n  }\n  return sigObj\n}\n\nexport function verifyES256K(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  const hash: Buffer = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const fullPublicKeys = authenticators.filter(({ publicKeyHex }) => {\n    return typeof publicKeyHex !== 'undefined'\n  })\n  const ethAddressKeys = authenticators.filter(({ ethereumAddress }) => {\n    return typeof ethereumAddress !== 'undefined'\n  })\n\n  let signer: PublicKey = fullPublicKeys.find(({ publicKeyHex }) => {\n    try {\n      return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer && ethAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, ethAddressKeys)\n  }\n\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  let signatures: EcdsaSignature[]\n  if (signature.length > 86) {\n    signatures = [toSignatureObject(signature, true)]\n  } else {\n    const so = toSignatureObject(signature, false)\n    signatures = [{ ...so, recoveryParam: 0 }, { ...so, recoveryParam: 1 }]\n  }\n\n  const checkSignatureAgainstSigner = (sigObj: EcdsaSignature): PublicKey => {\n    const hash: Buffer = sha256(data)\n    const recoveredKey: any = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam)\n    const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n    const recoveredCompressedPublicKeyHex: string = recoveredKey.encode('hex', true)\n    const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n\n    const signer: PublicKey = authenticators.find(\n      ({ publicKeyHex, ethereumAddress }) =>\n        publicKeyHex === recoveredPublicKeyHex ||\n        publicKeyHex === recoveredCompressedPublicKeyHex ||\n        ethereumAddress === recoveredAddress\n    )\n\n    return signer\n  }\n\n  const signer: PublicKey[] = signatures.map(checkSignatureAgainstSigner).filter(key => key != null)\n\n  if (signer.length === 0) throw new Error('Signature invalid for JWT')\n  return signer[0]\n}\n\nexport function verifyEd25519(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  const clear: Uint8Array = encode(data)\n  const sig: Uint8Array = base64ToBytes(base64url.toBase64(signature))\n  const signer: PublicKey = authenticators.find(({ publicKeyBase64 }) =>\n    nacl.sign.detached.verify(clear, sig, base64ToBytes(publicKeyBase64))\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (data: string, signature: string, authenticators: PublicKey[]) => PublicKey\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  'ES256K-R': verifyRecoverableES256K,\n  Ed25519: verifyEd25519\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import base64url from 'uport-base64url'\nimport { Buffer } from 'buffer'\nimport { Signer, EcdsaSignature, SignerAlgorithm } from './JWT'\n\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSigner(recoverable?: boolean): SignerAlgorithm {\n  function toJose({ r, s, recoveryParam }: EcdsaSignature): string {\n    const jose: Buffer = Buffer.alloc(recoverable ? 65 : 64)\n    Buffer.from(r, 'hex').copy(jose, 0)\n    Buffer.from(s, 'hex').copy(jose, 32)\n    if (recoverable) {\n      if (recoveryParam === undefined) {\n        throw new Error('Signer did not return a recoveryParam')\n      }\n      jose[64] = recoveryParam\n    }\n    return base64url.encode(jose)\n  }\n\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature)\n    } else {\n      throw new Error('expected a signer function that returns a signature object instead of string')\n    }\n  }\n}\n\nexport function Ed25519Signer(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error('expected a signer function that returns a string instead of signature object')\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSigner(),\n  'ES256K-R': ES256KSigner(true),\n  Ed25519: Ed25519Signer()\n}\n\nfunction SignerAlgorithm(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlgorithm\n","import VerifierAlgorithm from './VerifierAlgorithm'\nimport SignerAlgorithm from './SignerAlgorithm'\nimport base64url from 'uport-base64url'\nimport { DIDDocument, PublicKey } from 'did-resolver'\n\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number\n}\n\nexport type Signer = (data: string) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (payload: string, signer: Signer) => Promise<string>\n\ninterface JWTOptions {\n  issuer: string\n  signer: Signer\n  alg?: string\n  expiresIn?: number\n}\n\ninterface Resolvable {\n  resolve: (did: string) => Promise<DIDDocument | null>\n}\n\ninterface JWTVerifyOptions {\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n  resolver?: Resolvable\n}\n\ninterface DIDAuthenticator {\n  authenticators: PublicKey[]\n  issuer: string\n  doc: DIDDocument\n}\n\ninterface JWTHeader {\n  typ: 'JWT'\n  alg: string\n  [x: string]: any\n}\n\ninterface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string | string[]\n  iat?: number\n  nbf?: number\n  type?: string\n  exp?: number\n  rexp?: number\n  [x: string]: any\n}\n\ninterface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\ninterface Verified {\n  payload: any\n  doc: DIDDocument\n  issuer: string\n  signer: object\n  jwt: string\n}\n\ninterface PublicKeyTypes {\n  [name: string]: string[]\n}\nconst SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],\n  'ES256K-R': ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],\n  Ed25519: ['ED25519SignatureVerification']\n}\n\nconst defaultAlg = 'ES256K'\n\nfunction encodeSection(data: any): string {\n  return base64url.encode(JSON.stringify(data))\n}\n\nexport const NBF_SKEW: number = 300\n\n/**  @module did-jwt/JWT */\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('no JWT passed into decodeJWT')\n  const parts: RegExpMatchArray = jwt.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/)\n  if (parts) {\n    return {\n      header: JSON.parse(base64url.decode(parts[1])),\n      payload: JSON.parse(base64url.decode(parts[2])),\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`\n    }\n  }\n  throw new Error('Incorrect format JWT')\n}\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {SimpleSigner}      signer            a signer, reference our SimpleSigner.js\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @return   {Promise<Object, Error>}              a promise which resolves with a JWS string or rejects with an error\n */\nexport async function createJWS(payload: any, signer: Signer, header: Partial<JWTHeader> = {}): Promise<string> {\n  if (!header.alg) header.alg = defaultAlg\n  const signingInput: string = [encodeSection(header), encodeSection(payload)].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlgorithm(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload            payload object\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg         [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K.\n *                                                    Please use `header.alg` to specify the algorithm\n *  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js\n *  @param    {Object}            header             optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error\n */\nexport async function createJWT(\n  payload: any,\n  { issuer, signer, alg, expiresIn }: JWTOptions,\n  header: Partial<JWTHeader> = {}\n): Promise<string> {\n  if (!signer) throw new Error('No Signer functionality has been configured')\n  if (!issuer) throw new Error('No issuing DID has been configured')\n  if (!header.typ) header.typ = 'JWT'\n  if (!header.alg) header.alg = alg\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = (payload.nbf || timestamps.iat) + Math.floor(expiresIn)\n    } else {\n      throw new Error('JWT expiresIn is not a number')\n    }\n  }\n  const fullPayload = { ...timestamps, ...payload, iss: issuer }\n  return createJWS(fullPayload, signer, header)\n}\n\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubkeys` match.\n *\n *  @example\n *  const pubkey = verifyJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<PublicKey> | PublicKey}    pubkeys     The public keys used to verify the JWS\n *  @return   {PublicKey}                       The public key used to sign the JWS\n */\nexport function verifyJWS(jws: string, pubkeys: PublicKey | PublicKey[]): PublicKey {\n  if (!Array.isArray(pubkeys)) pubkeys = [pubkeys]\n  const { header, data, signature }: JWTDecoded = decodeJWT(jws)\n  const signer: PublicKey = VerifierAlgorithm(header.alg)(data, signature, pubkeys)\n  return signer\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = {\n    resolver: null,\n    auth: null,\n    audience: null,\n    callbackUrl: null\n  }\n): Promise<Verified> {\n  if (!options.resolver) throw new Error('No DID resolver has been configured')\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const { doc, authenticators, issuer }: DIDAuthenticator = await resolveAuthenticator(\n    options.resolver,\n    header.alg,\n    payload.iss,\n    options.auth\n  )\n  const signer: PublicKey = await verifyJWS(jwt, authenticators)\n  const now: number = Math.floor(Date.now() / 1000)\n  if (signer) {\n    const nowSkewed = now + NBF_SKEW\n    if (payload.nbf) {\n      if (payload.nbf > nowSkewed) {\n        throw new Error(`JWT not valid before nbf: ${payload.nbf}`)\n      }\n    } else if (payload.iat && payload.iat > nowSkewed) {\n      throw new Error(`JWT not valid yet (issued in the future) iat: ${payload.iat}`)\n    }\n    if (payload.exp && payload.exp <= now - NBF_SKEW) {\n      throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (!options.audience && !options.callbackUrl) {\n        throw new Error('JWT audience is required but your app address has not been configured')\n      }\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      const matchedAudience = audArray.find(item => options.audience === item || options.callbackUrl === item)\n\n      if (typeof matchedAudience === 'undefined') {\n        throw new Error(`JWT audience does not match your DID or callback url`)\n      }\n    }\n    return { payload, doc, issuer, signer, jwt }\n  }\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  resolver: Resolvable,\n  alg: string,\n  issuer: string,\n  auth?: boolean\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`No supported signature types for algorithm ${alg}`)\n  }\n  const doc: DIDDocument = await resolver.resolve(issuer)\n  if (!doc) throw new Error(`Unable to resolve DID document for ${issuer}`)\n  // is there some way to have authenticationKeys be a single type?\n  const authenticationKeys: boolean | string[] = auth\n    ? (doc.authentication || []).map(({ publicKey }) => publicKey)\n    : true\n  const authenticators: PublicKey[] = (doc.publicKey || []).filter(({ type, id }) =>\n    types.find(\n      supported =>\n        supported === type && (!auth || (Array.isArray(authenticationKeys) && authenticationKeys.indexOf(id) >= 0))\n    )\n  )\n\n  if (auth && (!authenticators || authenticators.length === 0)) {\n    throw new Error(`DID document for ${issuer} does not have public keys suitable for authenticationg user`)\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(`DID document for ${issuer} does not have public keys for ${alg}`)\n  }\n  return { authenticators, issuer, doc }\n}\n","import nacl from 'tweetnacl'\nimport { encode } from '@stablelib/utf8'\nimport { Buffer } from 'buffer'\nimport { Signer } from './JWT'\nimport { base64ToBytes } from './util'\nimport base64url from 'uport-base64url'\n\n/**\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  The signing function itself takes the data as a string parameter and returls a base64Url encoded signature\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  const privateKey: Uint8Array = base64ToBytes(base64PrivateKey)\n  return async data => {\n    const dataBytes: Uint8Array = encode(data)\n    const sig: Uint8Array = nacl.sign.detached(dataBytes, privateKey)\n    const b64UrlSig: string = base64url.encode(Buffer.from(sig))\n    return b64UrlSig\n  }\n}\n\nexport default NaclSigner\n"],"names":["sha256","payload","Buffer","from","sha256js","arrayBuffer","toEthereumAddress","hexPublicKey","data","slice","keccak_256","toString","secp256k1","EC","leftpad","size","length","repeat","base64ToBytes","s","Uint8Array","Array","prototype","call","const","toSignatureObject","signature","recoverable","rawsig","base64url","toBuffer","Error","sigObj","recoveryParam","verifyRecoverableES256K","authenticators","signatures","so","Object","signer","map","hash","recoveredKey","recoverPubKey","recoveredPublicKeyHex","encode","recoveredCompressedPublicKeyHex","recoveredAddress","find","ref","publicKeyHex","filter","key","algorithms","ES256K","fullPublicKeys","ethAddressKeys","keyFromPublic","verify","err","Ed25519","clear","sig","toBase64","nacl","sign","detached","VerifierAlgorithm","alg","impl","instanceOfEcdsaSignature","object","ES256KSigner","jose","alloc","r","copy","undefined","toJose","createJWS","header","defaultAlg","signingInput","encodeSection","join","jwtSigner","SignerAlgorithm","SUPPORTED_PUBLIC_KEY_TYPES","JSON","stringify","decodeJWT","jwt","parts","match","parse","decode","verifyJWS","jws","pubkeys","isArray","hexPrivateKey","startsWith","substring","privateKey","keyFromPrivate","base64PrivateKey","dataBytes","b64UrlSig","options","resolver","auth","audience","callbackUrl","issuer","types","resolve","doc","authenticationKeys","authentication","publicKey","supported","type","indexOf","id","resolveAuthenticator","iss","now","Math","floor","Date","nowSkewed","nbf","iat","exp","aud","item","typ","timestamps","expiresIn","fullPayload"],"mappings":"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"}